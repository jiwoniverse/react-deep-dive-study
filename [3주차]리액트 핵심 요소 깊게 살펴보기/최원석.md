# 2.1 JSX란?

JSX는 흔히 개발자들이 알고 있는 XML과 유사한 내장형 구문이며, 리액트에 종속적이지 않은 독자적인 문법으로 보는 것이 옳다. 이른바 ECMAScript라고 불리는 자바스크립트 표준의 일부는 아니다. 페이스북이 임의로 만든 새로운 문법이기 때문에 JSX는 반드시 트랜스파일러를 거쳐야 비로소 자바스크립트 런타임이 이해할 수 있는 의미 있는 자바스크립트 코드로 변환된다.

설계 목적은 다양한 트랜스파일러에서 다양한 속성을 가진 트리 구조를 토큰화해 자바스크립트로 변환하는데 초점을 두고 있다. 쉽게 이야기해서 JSX 내부에 트리 구조로 표현하고 싶은 다양한 것들을 작성해두고, 트랜스파일이라는 과정을 거쳐 자바스크립트가 이해할 수 있는 코드로 변경하는 것이 목표.

### 2.1.1 JSX의 정의

기본적으로 JSXElement, JSXAttributes, JSXChildren, JSXString으로 4가지 컴포넌트를 기반으로 구성.

1. JSXElement
   가장 기본 요소로, HTML의 요소(element)와 비슷한 역할을 한다. JSXElement가 되기 위해서는 다음과 같은 형태중 하나여야한다.
   JSXOpeningElement, JSXClosingElement, JSXSelfClosingElement, JSXFragment.

**JSXElementName** : JSXElement의 요소 이름으로 쓸 수 있는 것을 의미한다.

- JSXIdentifier
  JSX 내부에서 사용할 수 있는 식별자를 의미. 자바스크립트 식별자 규칙과 동일하다. 숫자로 시작하거나와 $와 \_외 다른 특수문자로 시작할 수 없다.

  ```jsx
    function Valid1(){
    	return <$></$>
    }

    function Valid2(){
    	return <_></_>
    }

    //불가능
    function Invalid(){
    	return <1></1>
    }
  ```

- JSXNamespacedName
  : 을 통해 서로 다른 식별자를 이어주는 것도 하나의 식별자로 취급한다. 한 개까지만 묶기 가능.

  ```jsx
  function valid(){
  	return <foo:bar></foo:bar>
  }

  //불가능
  function invalid(){
  	return <foo:bar:baz></foo:bar:baz>
  }
  ```

- JSXMemberExpression
  . 을 통해 다른 식별자를 이어준다. JSXNamespacedName과 다르게 여러개 이어서 하는 것도 가능.
  하지만 JSXNamespacedName과 이어서 사용하는 것은 불가능.

2. JSXAttributes
   JSXElement에 부여할 수 있는 속성을 의미한다. 단순히 속성이기 때문에 필수값이 아니다.
   **JSXSpreadAttributes** : 자바스크립트의 전개 연산자와 동일한 역할을 한다.
   {…AssignmentExpression}: 단순히 객체뿐만 아니라 자바스크립트에서 AssignmentExpression으로 취급되는 모든 표현식이 존재할 수 있다. 여기에는 조건문 표현식, 화살표 함수, 할당식 등이 있다.

3. JSXChildren
   JSXElement의 자식 값을 나타낸다. JSX는 속성을 가진 트리 구조를 나타내기 위해 만들어졌기 때문에 JSX로 부모와 자식 관계를 나타낼 수 있으며, 그 자식을 JSXChildren이라고 한다.

4. JSXStrings
   HTML에서 사용 가능한 문자열은 모두 JSXStrings에서도 가능하다. {,<,>,}을 제외한 모든 문자열이 가능하다. 자바스크립트와는 한 가지 중요한 차이점이 있는데 \로 시작하는 이스케이프 문자 형태소다. 자바스크립트에서는 특수문자를 처리할 때 사용되므로 몇 가지 제약 사항이 있지만 HTML에서는 제약없이 사용이 가능하다.

### 2.1.2 JSX 예제

```tsx
const ComponentA = <A>안녕하세요.</A>

const ComponentB = <A />

// 옵션을 {} 와 전개 연산자로 넣을 수 있다.
const ComponentC = <A {...{required : true}} />

// 속성만 있어도 가능
const ComponentD = <A required />

const ComponentE = <A  required={false} />

const ComponentF = (
	<A>
		<B text="리액트"/>
	</A>
)

const ComponentG = (
	<A>
		<B optionalChildren={<>안녕하세요</>} />
	</A>
)

...
```

### 2.1.3 JSX는 어떻게 자바스크립트에서 변환될까?

```tsx
//JSX
const element = <h1>Hello, world!</h1>;

//트랜스파일된 자바스크립트 코드
const element = React.createElement('h1', null, 'Hello, world!');
```

JSXElement를 첫 번째 인수로 선언해 요소를 정의한다. 그리고 옵셔널인 JSXChildren, JSXAttributes, JSXStrings는 이후 인수로 넘겨주어 처리한다. JSX반환값이 결국 React.createElement로 귀결된다는 사실을 파악할 수 있다.

```tsx
import { createElement } from 'react';

function TextOrHeading({
  isHeading,
  children,
}: PropsWithChildren<{ isheading: boolean }>) {
  return createElement(
    isHeading ? 'h1' : 'span',
    { className: 'text' }.children
  );
}
```

### 2.1.4 정리

JSX는 자바스크립트 코드 내부에 HTML과 같은 트리 구조를 가진 컴포넌트를 표현할 수 있다는 점에서 각광받고 있지만 인기만 있는 것은 아니다. HTML문법과 자바스크립트 문법이 뒤섞여서 코드 가독성을 해친다는 의견도 있다.

앞선 예제처럼 때에 따라서는 직접 createElement를 사용하여 컴포넌트를 구성하거나 어떻게 변환되는지 이해하면 좋을 것이다.

# 2.2 가상 DOM과 리액트 파이버

### 2.2.1 DOM과 브라우저 렌더링 과정

DOM(Document Object Model)은 웹페이지에 대한 인터페이스로 브라우저가 웹페이지의 콘텐츠와 구조를 어떻게 보여줄지에 대한 정보를 담고 있다.

[브라우저 렌더링](https://www.notion.so/6e4ee20326f1418bb8adbfd24727003a?pvs=21)

### 2.2.2 가상 DOM의 탄생 배경

렌더링이 완료된 이후에도 사용자의 인터랙션으로 웹페이지가 변경되는 상황 또한 고려해야한다. 특정한 요소의 색상이 변경되는 경우 페인팅만 일어나므로 비교적 빠르게 처리할 수 있다.

또 다른 경우에는 어떤 특정한 요소의 노출 여부가 변경되거나 사이즈가 변경되는 등 요소의 위치와 크기를 재계산하는 시나리오다. 이 경우에는 **레이아웃**이 일어나고 레이아웃은 필연적으로 리페인팅이 발생하기 때문에 더 많은 비용이 발생한다. 또한 DOM 변경이 일어나는 요소가 많은 자식 요소를 가지고 있는 경우에는 하위 자식 요소도 덩달아 변경되어야 하기 때문에 더 많은 비용을 브라우저가 사용하게 된다.

이러한 렌더링 이후 추가 렌더링 작업은 하나의 페이지에서 모든 작업이 일어나는 싱글 페이지 애플리케이션에서 더욱 많아진다. 라우팅이 변경되는 경우 사이드바나 헤더 같은 특정 요소를 제외하고 대부분의 요소를 삭제하고, 다시 삽입하고, 위치를 계산하는 등의 작업을 수행해야 하므로 특히 이러한 과정이 두드러진다.

이러한 문제점을 해결하기 위해 탄생한 것이 바로 가상 DOM이다. 가상 DOM은 말 그대로 실제 브라우저의 DOM이 아닌 리액트가 관리하는 가상의 DOM을 의미한다. 가상 DOM은 웹페이지가 표시해야할 DOM을 일단 메모리에 저장하고 리액트가 실제 변경에 대한 준비가 완료 됐을 때 실제 브라우저의 DOM에 반형한다.

### 2.2.3 가상 DOM을 위한 아키텍쳐, 리액트 파이버

가상 DOM과 렌더링 과정 최적화를 가능하게 해주는 것이 바로 리액트 파이버이다.

- 리액트 파이버란?

리액트 파이버는 리액트에서 관리하는 평범한 자바스크립트 객체이다. 파이버는 파이버 재조정자(fiber reconciler)가 관리하는데, 가상 DOM과 실제 DOM을 비교해 변경 사항을 수집하며, 차이가 있으면 변경에 관련된 정보를 가지고 파이버를 기준으로 화면에 렌더링을 요청하는 역할을 한다. 재조정(reconciler)는 용어가 낯설지만 가상 DOM과 실제 DOM을 비교하는 작업이라고 생각하면 된다.

파이버는 다음과 같은 일을 할 수 있다.

1. 작업을 작은 단위로 분할하고 쪼갠 다음, 우선순위를 매긴다.
2. 이러한 작업을 일시 중지하고 나중에 다시 시작할 수 있다.
3. 이전에 했던 작업을 다시 재사용하거나 필요하지 않은 경우에는 폐기할 수 있다.

중요한 것은 이러한 모든 과정이 **비동기**로 일어난다는 것이다.

그렇다면 파이버는 어떻게 구현되어 있을까 ? 파이버는 일단 하나의 작업 단위로 구성되어 있다. 리액트는 이러한 작업 단위를 하나씩 처리하고 finishedWork()라는 작업으로 마무리한다. 그리고 이 작업을 커밋해 실제 브라우저 DOM에 가시적인 변경 사항을 만들어 낸다.

1. 랜더 단계에서 리액트는 사용자에게 노출되지 않는 모든 비동기 작업을 수행한다. 그리고 이 단계에서 앞서 언급한 파이버의 작업, 우선순위를 지정하거나 중지시키거나 버리는 등의 작업이 일어난다.
2. 커밋 단계에서는 앞서 언급한 것처럼 DOM에 실제 변경 사항을 반영하기 위한 작업, commitWork()가 실행되는데, 이 과정은 앞서와 다르게 동기식으로 일어나고 중단될 수도 없다.

리액트의 핵심 원칙은 UI를 문자열, 숫자, 배열과 같은 값으로 관리하다는 것이다. 변수에 이러한 UI관련 값을 보관하고, 리액트의 자바스크립트 코드 흐름에 따라 이를 관리하고, 표현하는 것이 리액트이다.

- 리액트 파이버 트리

파이버트리는 리액트 내부에서 두 개가 존재한다. 하나는 현재 모습을 담은 파이버 트리이고, 다른 하나는 작업 중인 상태를 나타내는 workInProgress 트리이다. 리액트 파이버의 작업이 끝나면 리액트는 단순히 포인터만 변경해 workInProgress 트리를 현재 트리로 바꿔버린다. 이러한 기술을 **더블 버퍼링**이라고 한다. 이 더블 버퍼링은 커밋 단계에서 수행된다.

- 파이버의 작업 순서

일반적인 파이버 노드의 생성 흐름은 다음과 같다.

1. 리액트는 beginWork() 함수를 실행해 파이버 작업을 수행하는데, 더 이상 자식이 없는 파이버를 만날 때까지 트리 형식으로 시작된다.
2. 1번에서 작업이 끝난다면 completWork() 함수를 실행해 파이버 작업을 완료한다.
3. 형제가 있다면 형제로 넘어간다.
4. 2번,3번이 끝난다면 return으로 돌아가 자신의 작업이 완료됐음을 알린다.

최초 렌더링 시에는 모든 파이버를 새롭게 만들어야 했지만 이제는 파이버가 이미 존재하므로 되도록 새로 생성하지 않고 기존 파이버에서 업데이트된 props를 받아 파이버 내부에서 처리한다.

### 파이버와 가상 DOM

리액트 컴포넌트에 대한 정보를 1:1로 가지고 있는 것이 파이버이며, 이 파이버는 리액트 아키텍처 내부에서 비동기로 이뤄진다. 이러한 비동기 작업과 달리 실제 브라우저 구조인 DOM에 반영하는 것은 동기적으로 일어나야하고, 메모리상에서 먼저 수행해서 최종적인 결과물만 실제 브라우저 DOM에 적용하는 것이다.

---

# JSX

주로 리액트에서 사용하는 문법이고 UI 구성을 표현하는데 사용한다.

React 엘리먼트를 생성할 수 있다. React엘리먼트는 브라우저 DOM엘리먼트와 달리 일반 객체이다.

브라우저에서 실행하기 전에 바벨을 사용하여 일반 자바스크립트 형태의 코드로 변환한다.

자바스크립트에서 HTML을 작성하듯이 하기에 가독성이 높다. 또한, JSX를 사용하면 에러 및 경고 메시지를 표시할 수 있게 해준다.

### 문법 및 특징

- 반드시 태그는 닫혀야 한다.

<div>, <span> 과 같이 짝이 있는 태그의 경우 반드시 닫는 태그가 존재해야하며, 단독 태그의 경우에는 <img/>, <br/> 이런식으로 닫아줘야한다.

- 렌더링 될 루트 엘리먼트는 하나만 존재해야한다.

```tsx
ReactDOM.render(
	<div>
		Hello
	</div>
	<div>
		Bye
	</div>,
	document.getElementById('root')
);

=>
//하나의 div로 감싸주기.
ReactDOM.render(
	<div>
		<div>
			Hello
		</div>
		<div>
			Bye
		</div>
	</div>,
	document.getElementById('root')
);

//배열 문법 사용
ReactDOM.render(
	[ // 리액트 엘리먼트 배열을 반환
		<div key="1">Hello</div>, // 복수의 아이템을 리턴할 경우
		<div key="2">Bye</div>    // 각 엘리먼트에 key 속성과 고유값을 지정해야 한다.
	],
	document.getElementById('root')
);

//프래그먼트(Fragment) 패턴 사용
ReactDOM.render(
	<React.Fragment> // React.Fragment 컴포넌트로 리액트 엘리먼트를 감싸준다.
		<div>Hello</div>
		<div>Bye</div>
	</React.Fragment>
	document.getElementById('root')
);

// 프래그먼트 축약 구문 사용
ReactDOM.render(
	<>  // 빈태그로 감싸주기
		<div>Hello</div>
		<div>Bye</div>
	</>
	document.getElementById('root')
);
```

예제처럼 렌더링 될 리액트 엘리먼트에서 루트 엘리먼트가 두 개 이상일 경우 에러가 발생한다. 때문에 두 개 이상일 경우에 하나의 엘리먼트로 감싸져야한다.

Virtual DOM에서 컴포넌트 변화를 감지해 낼 때 효율적으로 비교할 수 있도록 컴포넌트 내부는 하나의 DOM 트리 구조로 이루어져야 한다는 규칙 때문이다.

# DOM, 가상 DOM

DOM, 즉 문서 객체 모델은 웹 페이지의 구조를 트리 형태로 나타내어, 각 요소를 노드로 취급한다. 이를 통해 프로그래밍 언어가 문서 구조, 스타일, 내용 등을 변경할 수 있다. 하지만 DOM을 직접 조작하는 것은 성능에 부정적인 영향을 줄 수 있다. 예를 들어, 작은 변경을 위해 전체 DOM 트리를 다시 렌더링하는 것은 비효율적이다.

이에 대한 해결책으로 가상 DOM이 등장했다. 가상 DOM은 실제 DOM의 가벼운 복사본이다. 변경 사항이 있을 때, 전체 DOM을 다시 렌더링하는 대신, 가상 DOM에 이러한 변경을 먼저 적용한다. 그 후, 실제 DOM과 가상 DOM을 비교하여 실제로 변경된 부분만 실제 DOM에 반영한다. 이 과정을 '재조정'이라고 한다.

DOM 트리와 가상 DOM 트리를 비교해보면, 이 두 트리는 기본적으로 웹 페이지의 구조를 나타내는 데 사용된다. 그러나 처리되는 방식과 포함하는 요소들에는 몇 가지 차이점이 있다.

1. **DOM 트리**: 실제 DOM 트리는 브라우저가 HTML 문서를 파싱한 후 생성하는 트리 구조이다. 이 트리는 HTML 태그를 노드로 가지며, 각 노드는 요소(Element), 텍스트(Text), 속성(Attribute) 등으로 구성된다. 예를 들어, **`<div>`** 태그는 요소 노드가 되고, 그 안의 텍스트는 텍스트 노드가 된다. 또한, 태그 내의 속성(예: class, id)도 별도의 노드로 취급될 수 있다.
2. **가상 DOM 트리**: 가상 DOM 트리는 실제 DOM 트리의 경량 버전으로, 주로 JavaScript 객체로 구성된다. 가상 DOM 노드는 실제 DOM 노드와 유사한 구조를 가지지만, 실제 DOM보다 적은 정보를 가진다. 가상 DOM 노드는 주로 태그의 종류, 속성, 자식 노드 등 기본적인 정보만을 포함한다. 이는 실제 DOM보다 더 빠르게 생성하고 업데이트할 수 있게 해준다.

이 두 트리의 주요 차이점은 실제 DOM 트리가 브라우저의 렌더링 엔진에 의해 직접 관리되고, 실제 화면에 렌더링되는 반면, 가상 DOM 트리는 JavaScript를 통해 메모리 상에만 존재하고, 실제 DOM의 변경사항을 효율적으로 관리하기 위해 사용된다는 것이다.

# 브라우저 렌더링 과정

# 렌더링

### 렌더링이란?

렌더링이란 HTML, CSS, 자바스크립트 등 개발자가 작성한 문서가 브라우저에서 출력되는 과정을 말한다.

브라우저 마다 다르지만, 브라우저는 렌더링을 수행하는 렌더링 엔진을 가지고 있다. 크롬은 블링크, 사파리는 웹킷, 파이어폭스는 게코라는 렌더링 엔진을 사용한다.

### 브라우저의 웹 렌더링 과정

1. **파싱**

HTML 파싱 : 브라우저가 웹 페이지를 로드할 때, HTML 파일을 읽기 시작한다. 이를 파싱하여 DOM(Document Object Model) 트리를 생성한다.

1. **바이트(Byte) 단계**: 웹 서버에서 전송받은 원시 데이터는 바이트 형태입니다.
2. **문자(Character) 단계**: 바이트들은 해당 문서의 인코딩(예: UTF-8)을 사용하여 문자로 변환됩니다.
3. **토큰(Token) 단계**: 이 문자들은 HTML의 문법에 따라 여러 토큰으로 변환됩니다. 예를 들어, 태그나 속성 등의 토큰으로 변환될 수 있습니다.
4. **노드(Node) 단계**: 토큰들은 해당하는 DOM 노드로 변환됩니다.
5. **DOM 트리 생성**: 이 노드들은 서로 연결되어 DOM 트리를 형성합니다.

**쉽게 말해서, DOM은 HTML 문서를 파싱(분해하고 구조 생성)한 자료구조 형태의 결과물이다.**

CSS 파싱 : CSS 파일 및 style 태그 내의 스타일 정보도 파싱되어 CSSOM(CSS Object Model) 트리가 생성된다.

렌더링 엔진은 **처음부터 한 줄씩 순차적으로 파싱하며 DOM을 생성**한다. 이때, 중간에 **CSS를 로드하는 link나 style 태그를 만나면 DOM 생성을 일시 중단**한다.

**렌더 트리 생성**

- 렌더 트리 : DOM 및 CSSOM 트리를 병합하여 렌더 트리를 생성한다. 이 렌더 트리는 실제로 화면에 그려지는 요소들만 포함하며, ‘display : none;’과 같이 화면에 표시되지 않는 요소는 렌더 트리에 포함되지 않는다.

  **레이아웃**

- 렌더 트리가 생성된 후, 브라우저는 각 노드가 화면의 어디에 위치할지 계산하는 레이아웃 단계를 수행한다. 이 단계에서 각 요소의 크기와 위치 정보가 결정된다.

**페인트**

- 레이아웃 단계가 완료된 후, 브라우저는 렌더 트리의 각 노드를 화면에 그리는 페인트 과정을 진행한다. 여기서 배경색, 텍스트 생삭, 이미지, 그림자 등 시각적 스타일이 적용된다.

**합성**

- 여러 레이어로 나뉜 요소들이 합성되어 최종적으로 화면에 표시된다.

### 리플로우(Reflow), 리페인트(Repaint)

### **1. 리플로우 (Reflow)**

- **정의**: 리플로우는 브라우저가 웹 페이지의 요소의 위치와 크기를 다시 계산하는 과정을 의미한다. 이는 DOM의 변경, CSS 스타일의 변경, 또는 사용자의 행동(예: 브라우저 창 크기 조정)으로 인해 발생할 수 있다.
- **원인**
  - 요소의 크기나 위치를 변경할 때
  - 요소의 내용이 변경될 때 (텍스트 추가/삭제 등)
  - 요소가 페이지에 추가되거나 삭제될 때
  - 페이지 초기 렌더링
  - 브라우저 창 크기 변경
  - 폰트 변경
- **성능에 대한 영향**: 리플로우는 비용이 많이 드는 연산이다. 자주 발생하면 페이지의 응답성이 떨어질 수 있다. 특히 모바일 기기와 같이 처리 능력이 제한된 환경에서는 성능 저하의 원인이 될 수 있다.

### **2. 리페인트 (Repaint)**

- **정의**: 리페인트는 요소의 외형적인 부분(색상, 그림자 등)이 변경되어 화면에 다시 그려야 할 때 발생하는 과정을 의미. 이는 리플로우와 다르게 요소의 크기나 위치는 변경되지 않는다.
- **원인**:
  - 요소의 색상 변경
  - 그림자 추가/변경
  - 투명도 변경
- **성능에 대한 영향**: 리페인트는 리플로우만큼 비용이 많이 드는 연산은 아니지만, 빈번하게 발생하면 성능에 부정적인 영향을 줄 수 있다.

기존 요소에 변경 사항이 생겼다고 해서 항상 리플로우(Reflow)-리페인트(Repaint)가 일어나는 것은 아니고, 레이아웃에 영향이 미치지 않는 단순한 색상 변경 같은 변경사항은 리플로우(Reflow) 수행 없이 바로 리페인트(Repaint)만 수행. (리플로우가 일어나면 반드시 리페인트가 일어남)

**다음은 리플로우(Reflow)가 일어나는 대표적인 속성들입니다.**

position, width, height, margin, padding, border, border-width, font-size, font-weight, line-height, text-align, overflow

**다음은 리페인트(Repaint)만 일어나는 대표적인 속성들입니다.**

background, color, text-decoration, border-style, border-radius

## 최적화 방법

**노출 제어를 통한 리플로 최소화 방법**

요소의 스타일을 변경하면 리페인트는 반드시 일어나며, 변경 형태에 따라 리플로도 일어납니다. 변경하는 스타일 속성의 수가 적다면 변경에 따른 렌더링 성능 저하가 부담스럽지 않겠지만 여러 속성의 스타일값을 변경하는 경우라면 얘기가 달라집니다.

**display 속성**

기본적으로 리플로와 리페인트는 모두 화면에 변경된 사항이 반영되는 시점에 발생합니다. **여러 속성의 스타일을 변경하는 중간 단계에서는 화면에 표시하지 않고, 작업이 완료되고 최종 경과가 반영되는 마지막 시점에 요소를 다시 표시한다면 리플로와 리페인트의 발생횟수를 크게 줄일 수 있습니다.**

다음의 코드를 살펴보면, 이 코드는 값을 여러번 변경하며 값이 변경될 때마다 리플로와 리페인트가 발생합니다.

```
var element = document.getElementById("box1");

for(var i=50; i<100; i++) {
    element.style.width = i + "px";
}

for(i=1; i<=50; i++) {
    element.style.borderWidth = i + "px";
}
```

하지만 다음과 같이 요소를 보이지 않게 하고 모든 변경이 반영된 이후에 표시하면 처음과 마지막 시점 두번으로 리플로 발생 횟수가 줄어듭니다.

```
var element = document.getElementById("box1");
element.style.display = "none";

for(var i=50; i<100; i++) {
    element.style.width = i + "px";
}

for(i=1; i<=50; i++) {
    element.style.borderWidth = i + "px";
}

element.style.display = "block";
```

첫번째 코드의 경우, 중간 단계는 노출 제어를 하지 않고 요소의 모든 변경 과정이 바로바로 렌더링돼 노출 됩니다. 따라서 변경 과정이 지속되는 동안 계속해서 리플로와 리페인트가 발생합니다. 두번째 코드는 변경 과정을 실행하기 전에 해당 요소가 노출되지 않게 처리한 후 변경 과정을 처리합니다. 이렇게 처리하면 display="none" 시점(이때 왼쪽 요소가 사라진 영역으로 오른쪽 요소가 이동하며 리플로와 리페인트가 발생한다)과 변경 완료 시점의 display="block"으로 두번만 리플로와 리페인트가 발생합니다)

**노드 복제**

변경하려는 요소의 노드를 복제한 후 복제된 노드에 필요한 작업을 실행하는 방법입니다. **복제된 노드는 DOM 트리에 추가된 상태가 아니므로 렌더링 성능에 영향을 줄 수 있는 작업을 실행하더라도 리플로나 리페인트가 발생하지 않습니다.**

```
var element = document.getElementById("box1");
var clone = element.cloneNode(true);     // 원본 노드를 복제한다.

for(var i=0; i < 100; i++) {
    clone.style.width = i + "px";
}

// 변경된 복제 노드를 DOM 트리에 반영하기 위해 기존 노드와 치환한다.
parentNode.replaceChild(clone, element);
```

작업이 모두 완료된 이후 복제된 노드를 원래 노드와 치환해 DOM 트리에 변경된 사항이 적용되게 합니다. 그러면 **치환 시점에만 리플로와 리페인트가 발생합니다.**

**캐싱**

여기서 설명하는 캐싱은 별도의 변수에 자주 사용하는 값을 저장하는 것입니다. **특정 속성과 메서드를 사용하기만 해도 리플로가 발생할 수 있습니다. 자주 사용하는 속성의 값이나 메서드의 반환값을 변수에 저장하면 직접 속성이나 메서드를 호출하는 횟수를 줄여 성능을 향상시킬 수 있습니다.**

다음과 같은 코드는 반복문을 실행할 때마다 리플로를 유발하는 속성을 호출합니다.

```
// 아래와 같이 반복 구문에서 리플로 유발 속성을 요청하는 것은 피해야 한다.
for(condition) {
    el.style.width = el.scrollWidth + "px";
    el.style.left - el.scrollLeft + "px";
}
```

이 경우 값을 최대한 별도의 변수에 캐싱해 자주 호출되지 않게 하면 리플로의 발생 빈도를 낮출 수 있습니다.

```
// 리플로를 유발할 수 있는 scrollWidth 속성과 scrollLeft 속성의 값은
// 반복 구문을 실행하기 전에 변수에 캐싱해 리플로 발생을 최소화한다.
var nWidth = el.scrollWidth, nLeft = el.scrollLeft;

for(condition) {
    el.style.width = nWidth + "px";
    el.style.left = nLeft + "px";
}
```

**createDocumentFragment() 메서드 사용**

브라우저의 화면에 표시되는 페이지는 DOM 트리와 렌더링 트리를 통해 표시됩니다. **화면에 보이는 DOM 트리는 메인 DOM 객체라 할 수 있는데, 간혹 DOM API 메서드를 사용해 노드 작업을 실행해야 할 때가 있습니다. 이때 메인 DOM 객체와는 별개의 새로운 DOM 객체를 생성해 사용하면 렌더링 성능을 좀 더 향상시킬 수 있습니다.** 새로운 DOM 객체는 다음 예제와 같이 document.createDocumentFragment() 메서드를 사용해 생성합니다.

```
// 새로운 DOM 객체를 생성한다.
var fragment = document.createDocumentFragment();

// elms는 메인 DOM에 추가해야 하는 DOM 컬렉션 객체라고 가정하며, 새로운 DOM 객체에 반복문으로 추가한다.
for(var e=0; e<elems.length; e++) {
    fragment.appendChild(elems[e]);
}

// 메인 DOM 객체, 즉 화면에 보이는 DOM 트리에서 <div> 요소를 선택한다.
var div = document.getElementsByTagName("div");

// 선택된 <div> 요소를 반복문으로 순회하며 새로운 DOM 객체에 추가된 노드의 복제본을 메인 DOM 객체에 추가한다.
for(var i=0; i < div.length; i++) {
    div[i].appendChild(fragment.cloneNode(true));
}
```

## 자바스크립트 파싱과 실행

CSS를 파싱할 때 link나 script를 만나면 그 아래의 DOM 생성을 멈추고 CSSOM을 생성했던 것 처럼 script 태그도 동일하다. 다른 점은 **CSSOM도 렌더링 엔진이 만들었다면,  script 태그 내의 자바스크립트 코드를 파싱할 때는 렌더링 엔진이 자바스크립트 엔진에게 제어권을 넘긴다.** *(이를 blocking이 일어났다고도 한다!)* 이후 **자바스크립트 파싱과 실행이 종료되면 렌더링 엔진으로 다시 제어권이 넘어가 HTML 파싱이 중단된 시점부터 다시 시작하여 DOM 생성을 재개**한다.

script closing tag 코드를 만나면 위에서 아래로 **동기적**으로 이루어지던 파싱이 중단된다. 이는 **script 태그 위치에 따라 HTML 파싱이 블로킹되어 DOM 생성이 지연될 수 있다는 의미이므로 script 태그의 위치는 중요한 의미를 갖는다!**

위와 같이 **DOM API를 사용하는 코드가 script 안에 있는데 body 태그보다 위에 위치한다면?** getElementId('apple')에서 **HTML 엘리먼트가 만들어지지 않았으므로** ID가 apple인 요소를 찾지 못하고, 아래의 style도 실행할 수 없다. 따라서 위와 같은 오류가 발생하게 된다.

이전의 코드를 위와 같이 script 태그가 body 태그 아래에 위치하도록 수정한다면, **script 태그로 인한 HTML 블로킹이 발생하지 않아** HTML 요소가 다 만들어진 뒤 script 태그가 실행된다.

**따라서 body 요소의 가장 아래에 script 태그를 위치하는 것은 상대적으로 더 권장된다. DOM이 완성된 후 JS가 DOM을 조작하니 엘리먼트를 찾지 못하는 오류도 없고, HTML 블로킹이 없어 페이지 로딩 시간이 단축되기 때문이다.**

> ❓
>
> **자바스크립트 파일이 body 위에 위치한 경우**
>
> 👉🏼 JS 파일의 크기가 크고 인터넷 환경이 느린 곳이라면 페이지를 보는데 오랜 시간이 소요된다.
>
> ❓
>
> **자바스크립트 파일이 body 아래에 위치한 경우**
>
> 👉🏼페이지를 먼저 볼 수는 있지만 페이지가 JS 파일에 의존적인 경우 완전하지 않은 페이지를 볼 수 있다.

# 리액트 파이버

Fiber는 작업의 우선 순위를 설정하고, 중단 및 재개가 가능한 비동기적인 방식으로 작업을 처리할 수 있게 한다. React Fiber는 가상 DOM의 재조정 과정을 관리한다. 예를 들어, 대규모 UI 업데이트가 있을 때, Fiber는 이를 여러 개의 작은 단위로 나누어 처리할 수 있으며, 중요한 업데이트를 우선적으로 처리할 수 있다. UI 업데이트를 더 작은 작업 단위로 나누어, 메인 스레드의 부하를 줄이고 브라우저의 렌더링 능력을 향상시킨다.

# 2.3 클래스형 컴포넌트

클래스형 컴포넌트를 사용하면 가장 자주 언급되는 것 중 하나는 생명주기이다.

- 마운트 : 컴포넌트가 마운팅 되는 시점.
- 업데이트 : 이미 생성된 컴포넌트의 내용이 변경되는 시점
- 언마운트 : 컴포넌트가 더 이상 존재하지 않는 시점

[리액트 생졍주기 다이어그램](https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)

### 클래스형 컴포넌트의 한계

- 데이터의 흐름을 추적하기 어렵다
- 애플리케이션 내부 로직의 재사용이 어렵다
- 기능이 많아질수록 컴포넌트의 크기가 커진다.
- 클래스는 함수에 비해 상대적으로 어렵다.
- 코드 크기를 최적화하기 어렵다.
- 핫 리로딩을 하는 데 상대적으로 불리하다.

### 함수형 컴포넌트

- 생명주기 메서드의 부재 : 함수형 컴포넌트는 props를 받아 단순히 리액트 요소만 반환하는 함수인 반면, 클래스형 컴포넌트는 render 메서드가 있는 React.Component를 상속 받아 구현하는 자바스크립트 클래스임.

함수형 컴포넌트는 렌더링이 일어날 때마다 그 순간의 값인 props와 state를 기준으로 렌더링 된다. props와 state가 변경된다면. 다시 한 번 그 값을 기준으로 함수가 호출된다고 볼 수 있음. 반면 클래스형 컴포넌트는 시간의 흐름에 따라 변화하는 this를 기준으로 렌더링 된다.

---

### 참고 블로그

[https://velog.io/@gyumin_2/React-JSX란정의-장점-문법-특징-등](https://velog.io/@gyumin_2/React-JSX%EB%9E%80%EC%A0%95%EC%9D%98-%EC%9E%A5%EC%A0%90-%EB%AC%B8%EB%B2%95-%ED%8A%B9%EC%A7%95-%EB%93%B1)

https://12bme.tistory.com/140

[https://medium.com/개발자의품격/브라우저의-렌더링-과정-5c01c4158ce](https://medium.com/%EA%B0%9C%EB%B0%9C%EC%9E%90%EC%9D%98%ED%92%88%EA%B2%A9/%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%EC%9D%98-%EB%A0%8C%EB%8D%94%EB%A7%81-%EA%B3%BC%EC%A0%95-5c01c4158ce)

https://oliviakim.tistory.com/80

https://lakelouise.tistory.com/196
