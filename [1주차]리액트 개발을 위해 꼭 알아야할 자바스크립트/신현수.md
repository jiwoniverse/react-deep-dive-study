# 1. 리액트 개발을 위해 꼭 알아야 할 자바스크립트

## 1.1 자바스크립트의 동등 비교

### 1.1.1 자바스크립트의 데이터 타입

자바스크립트의 모든 값은 데이터 타입을 가지고 있으며, 원시 타입과 객체 타입으로 나눌 수 있습니다.

```
원시 타입
- boolean
- null
- undefined
- number
- string
- symbol
- bigint

객체 타입
- object
```

원시 타입이란 객체가 아닌 모든 타입을 의미하며 메서드를 갖지 않는다.

- 메서드란 ? 객체에 포함된 함수로, 객체의 동작을 정의하며 데이터를 조작하거나 특정 작업을 수행할 수 있게 해줍니다.

```
const data = {
    name: 'John',
    greet: function() {
        console.log('Hello, ' + this.name);
    }
};

data.greet(); // "Hello, John"
```

#### undefined

- 선언한 후 값을 할당하지 않은 변수 또는 값이 주어지지 않은 인수에 자동으로 할당되는 값
- null과 undefined는 각각 null, undefined라는 값만 가질 수 있으며 그 밖의 타입은 가질 수 있는 값이 두 개 이상 존재한다.

```
let foo

typeof foo === 'undefined' // true

function bar(hello) {
    return hello
}

typeof bar() === 'undefined' // true
```

#### null

아직 값이 없거나 비어 있는 값을 표현할 때 사용한다.

```
typeof null === 'object' // true
```

null은 object라는 결과가 반환되며 undefined는 '선언됐지만 할당되지 않은 값', null은 '명시적으로 비어 있음을 나타내는 값'으로 사용하는 것이 일반적이다.

#### undefeind와 null의 차이를 보여주는 예시 코드

```
// undefined 예시
let undefinedVariable;
console.log(undefinedVariable); // undefined

// null 예시
let nullVariable = null;
console.log(nullVariable); // null

// 함수에서 undefined 반환
function doNothing() {
  // 아무것도 반환하지 않음
}
console.log(doNothing()); // undefined

// 객체에서 undefined와 null의 차이
const obj = {
  a: undefined,
  b: null,
};

console.log(obj.a); // undefined
console.log(obj.b); // null

// typeof 연산자 사용
console.log(typeof undefinedVariable); // "undefined"
console.log(typeof nullVariable); // "object"

// 엄격한 비교
console.log(undefinedVariable === undefined); // true
console.log(nullVariable === null); // true

// 느슨한 비교 (둘 다 "값이 없음"을 의미하기 때문에 true)
console.log(undefinedVariable == nullVariable); // true

// 엄격한 비교 (타입이 다르기 때문에 false)
console.log(undefinedVariable === nullVariable); // false
```

#### boolean

- 참과 거짓만을 가질 수 있는 데이터 타입이다.
- true, false와 같은 boolean 형의 값 외에도 조건문에서 마치 true와 false처럼 취급되는 truthy, falsy값이 존재한다.

```
console.log(typeof false, false, !!false); // "boolean false false"
console.log(typeof 0, 0, !!0); // "number 0 false"
console.log(typeof "", "", !!""); // "string  false"
console.log(typeof null, null, !!null); // "object null false"
console.log(typeof undefined, undefined, !!undefined); // "undefined undefined false"
console.log(typeof NaN, NaN, !!NaN); // "number NaN false"

// Truthy 값 예시
console.log(typeof true, true, !!true); // "boolean true true"
console.log(typeof 42, 42, !!42); // "number 42 true"
console.log(typeof "hello", "hello", !!"hello"); // "string hello true"
console.log(typeof {}, {}, !!{}); // "object {} true"
console.log(typeof [], [], !![]); // "object [] true"
```

!! 연산자를 사용하는 이유는 값을 명시적으로 boolean 타입으로 변환하여 값을 보여주기 위함입니다.

#### number

- -(2^53 - 1) ~ 2^53 - 1 사이의 값을 저장할 수 있습니다.
- 2진수, 8진수, 16진수 등의 별도 데이터 타입을 제공하지 않으므로 각 진수로 값을 표현해도 모두 10진수로 해석되어 값으로 표시됩니다.

#### BigInt

- number가 다룰 수 있는 숫자 크기의 제한을 극복하기 위해 ES2020에서 새롭게 나온 타입

#### string

- ', ", `(문자열 리터럴 백틱)으로 표현할 수 있습니다.
- 백틱은 따옴표와 달리 줄바꿈을 할 수 있고 문자열 내부에 표현식을 쓸 수 있습니다.
- 문자열은 원시 타입이며 변경 불가능합니다. 문자열이 한번 생성되면 그 문자열은 변경할 수 없습니다.

```
const foo = 'bar'

console.log(foo[0]) // 'b'

foo[0] = 'a'

console.log(foo[0]) // bar
```

#### Symbol

- 중복되지 않은 고유한 값을 나타내기 위해서 사용되며 반드시 Symbol()을 사용해야 합니다.

```
const key = Symbol('key')
const key2 = Symbol('key')

key === key2 // false

// 동일한 값을 사용하기 위해서는 Symbol.for를 활용
Symbol.for('hello') === Symbol.for('hello) // true
```

#### 객체 타입

- 앞서 7가지의 원시 타입 이외의 모든 타입은 다 객체 타입이다. 배열, 함수, 정규식, 클래스 등이 있습니다.

- 객체 타입은 참조를 전달한다고 해서 참조 타입으로도 불립니다.

### 1.1.2 값을 저장하는 방식의 차이

- 원시 타입과 객체 타입의 가장 큰 차이점은 값을 저장하는 방식의 차이입니다.
- 원시 타입은 불변 형태의 값으로 저장되며 이 값은 변수 할당 시점에 메모리 영역을 차지하고 저장됩니다.
- 객체는 프로퍼티를 삭제, 추가, 수정할 수 있으므로 원시 값과 다르게 변경 가능한 형태로 저장되며 복사할 때도 값이 아닌 참조를 전달하게 됩니다.

프토퍼티란? : 객체의 속성을 나타내는 키-값 쌍입니다. 여러 개의 프로퍼티를 가질 수 있으며, 각 프로퍼티는 key, value로 구성됩니다. 프로퍼티는 추가, 삭제, 수정할 수 있으므로 변경 가능한(mutable) 형태로 저장됩니다.

#### 원시 타입 예시

```
let a = 10;
let b = a; // 값 복사
b = 20;

console.log(a); // 10
console.log(b); // 20

let str1 = "Hello";
let str2 = str1; // 값 복사
str2 = "World";

console.log(str1); // "Hello"
console.log(str2); // "World"
```

#### 객체 타입 예시

```
let obj1 = { name: "John" };
let obj2 = obj1; // 참조 복사
obj2.name = "Doe";

console.log(obj1.name); // "Doe"
console.log(obj2.name); // "Doe"

// 배열
let arr1 = [1, 2, 3];
let arr2 = arr1; // 참조 복사
arr2.push(4);

console.log(arr1); // [1, 2, 3, 4]
console.log(arr2); // [1, 2, 3, 4]

// 함수
function greet() {
  console.log("Hello");
}

let greetCopy = greet; // 참조 복사
greetCopy(); // "Hello"

// 정규식
let regex1 = /hello/;
let regex2 = regex1; // 참조 복사
console.log(regex2.test("hello")); // true

// 클래스
class Person {
  constructor(name) {
    this.name = name;
  }
}

let person1 = new Person("Alice");
let person2 = person1; // 참조 복사
person2.name = "Bob";

console.log(person1.name); // "Bob"
console.log(person2.name); // "Bob"
```

객체는 값을 저장하는 것이 아니라 참조를 저장하기 때문에 동일하게 선언한 객체라고 하더라도 다른 참조를 바라보기 때문에 비교 시 false를 반환합니다.

```
// 두 개의 동일한 내용을 가진 객체를 생성
let obj1 = { name: "Alice", age: 25 };
let obj2 = { name: "Alice", age: 25 };

// 두 객체의 비교
console.log(obj1 === obj2); // false (서로 다른 참조를 가리키기 때문에)

// 같은 객체를 가리키는 두 변수를 생성
let obj3 = obj1;

// 같은 객체를 가리키는 두 변수의 비교
console.log(obj1 === obj3); // true (같은 참조를 가리키기 때문에)
```

### 1.1.3 Object.is

Object.is는 두 개의 인수를 받으며 인수 두 개가 동일한지 확인하고 반환하는 메서드입니다.

```
-0 === +0 // true
Object.is(-0, +0) // false

Number.NaN === NaN // false
Object.is(Number.NaN, NaN) // true

NaN === 0 / 0 // false
Object.is(NaN, 0 / 0) // true
```

하지만 객체 비교에 있어서는 ===와 동일하게 작동합니다. 왜냐면 두 방법 모두 객체의 참조를 비교하기 때문입니다.
